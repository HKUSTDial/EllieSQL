from typing import Dict
from .base import SchemaLinkerBase
from ...core.llm import LLMBase
from .prompts.schema_prompts import ENHANCED_SCHEMA_SYSTEM, BASE_SCHEMA_USER
from ...core.schema.manager import SchemaManager
from ...core.utils import load_json
import os
import json

class EnhancedSchemaLinker(SchemaLinkerBase):
    """Schema Linker using enhanced schema information"""
    
    def __init__(self, 
                llm: LLMBase, 
                model: str = "gpt-3.5-turbo-0613",
                temperature: float = 0.0,
                max_tokens: int = 1000,
                max_retries: int = 3):
        super().__init__("EnhancedSchemaLinker", max_retries)
        self.llm = llm
        self.model = model
        self.temperature = temperature
        self.max_tokens = max_tokens
        self.schema_manager = SchemaManager()
        
    def _validate_linked_schema(self, linked_schema: Dict, database_schema: Dict) -> bool:
        """
        Validate that the tables and columns in the linked schema exist in the original schema
        
        :param linked_schema: The schema generated by Schema Linking
        :param database_schema: The original database schema
            
        :return: bool: Whether the validation passes
        """
        try:
            # Create a set of tables and columns from the original schema for quick lookup
            db_tables = {table["table"]: set(table["columns"].keys()) 
                        for table in database_schema["tables"]}
            
            # Validate each linked table
            for table in linked_schema["tables"]:
                table_name = table["table"]
                
                # Validate that the table exists
                if table_name not in db_tables:
                    self.logger.warning(f"Table '{table_name}' does not exist in the original schema")
                    return False
                
                # Validate that the column exists in the corresponding table
                for col in table["columns"]:
                    if col not in db_tables[table_name]:
                        self.logger.warning(
                            f"Column '{col}' does not exist in table '{table_name}'"
                        )
                        return False
                        
                # Validate that the primary key exists (if any)
                if "primary_keys" in table:
                    for pk in table["primary_keys"]:
                        if pk not in db_tables[table_name]:
                            self.logger.warning(
                                f"Primary key '{pk}' does not exist in table '{table_name}'"
                            )
                            return False
                            
                # Validate that the foreign key exists (if any)
                if "foreign_keys" in table:
                    for fk in table["foreign_keys"]:
                        # Validate that the foreign key column exists
                        if fk["column"] not in db_tables[table_name]:
                            self.logger.warning(
                                f"Foreign key column '{fk['column']}' does not exist in table '{table_name}'"
                            )
                            return False
                        
                        # Validate that the referenced table and column exist
                        ref_table = fk["referenced_table"]
                        ref_column = fk["referenced_column"]
                        
                        if ref_table not in db_tables:
                            self.logger.warning(
                                f"Referenced table '{ref_table}' does not exist in the original schema"
                            )
                            return False
                            
                        if ref_column not in db_tables[ref_table]:
                            self.logger.warning(
                                f"Referenced column '{ref_column}' does not exist in table '{ref_table}'"
                            )
                            return False
                        
            return True
            
        except Exception as e:
            self.logger.error(f"Error occurred while validating linked schema: {str(e)}")
            return False
            
    def _enhance_linked_schema(self, linked_schema: Dict, database_schema: Dict) -> Dict:
        """
        Enhance the linked schema by adding necessary primary keys, foreign keys, and additional information
        1. Add necessary primary key columns to each relevant table
        2. Process foreign key relationships between tables
        3. Add additional information to all columns

        :param linked_schema: The schema generated by Schema Linking
        :param database_schema: The original database schema
            
        :return: Dict: The enhanced schema
        """
        # Create a mapping of database table information for quick lookup
        db_tables = {table["table"]: table for table in database_schema["tables"]}
        
        # Get all involved table names
        linked_table_names = [table["table"] for table in linked_schema["tables"]]
        
        # Step 1: Add necessary columns (primary keys and foreign keys) to each table
        for table in linked_schema["tables"]:
            table_name = table["table"]
            db_table = db_tables[table_name]
            
            # 1.1 Add primary key columns
            if db_table["primary_keys"]:
                if "primary_keys" not in table:
                    table["primary_keys"] = db_table["primary_keys"]
                
                # Ensure primary key columns are in columns
                for pk in db_table["primary_keys"]:
                    if pk not in table["columns"]:
                        table["columns"].append(pk)
                        self.logger.info(f"Add primary key column '{pk}' to table '{table_name}'")
            
        # 1.2 Process foreign key relationships between tables
        if len(linked_table_names) > 1:  # Only process foreign keys when multiple tables are involved
            for fk in database_schema.get("foreign_keys", []):
                src_table = fk["table"][0]
                dst_table = fk["table"][1]
                src_col = fk["column"][0]
                dst_col = fk["column"][1]
                
                # Only process foreign keys between involved tables
                if src_table in linked_table_names and dst_table in linked_table_names:
                    # Find the source and destination tables in linked_schema
                    src_table_obj = next(t for t in linked_schema["tables"] if t["table"] == src_table)
                    dst_table_obj = next(t for t in linked_schema["tables"] if t["table"] == dst_table)
                    
                    # Ensure foreign key columns are in columns
                    for table_obj, col_name in [(src_table_obj, src_col), (dst_table_obj, dst_col)]:
                        if col_name not in table_obj["columns"]:
                            table_obj["columns"].append(col_name)
                            table_name = table_obj["table"]
                            if table_obj == src_table_obj:
                                self.logger.info(f"Add foreign key column '{src_col}' to table '{src_table}'")
                            else:
                                self.logger.info(f"Add referenced column '{dst_col}' to table '{dst_table}'")
                    
                    # Add foreign key relationship information
                    if "foreign_keys" not in src_table_obj:
                        src_table_obj["foreign_keys"] = []
                        
                    # Check if the same foreign key relationship already exists
                    fk_exists = any(
                        fk["column"] == src_col and 
                        fk["referenced_table"] == dst_table and 
                        fk["referenced_column"] == dst_col 
                        for fk in src_table_obj.get("foreign_keys", [])
                    )
                    
                    if not fk_exists:
                        src_table_obj["foreign_keys"].append({
                            "column": src_col,
                            "referenced_table": dst_table,
                            "referenced_column": dst_col
                        })
                        self.logger.info(
                            f"Add foreign key relationship: {src_table}.{src_col} -> {dst_table}.{dst_col}"
                        )
        
        # Step 2: Add additional information to all columns
        for table in linked_schema["tables"]:
            table_name = table["table"]
            db_table = db_tables[table_name]
            
            # Add additional information to all columns
            columns_info = {}
            for col in table["columns"]:  # Now includes all columns (original, primary keys, and foreign keys)
                if col in db_table["columns"]:
                    col_info = db_table["columns"][col]
                    columns_info[col] = {
                        "type": col_info["type"],
                        "expanded_name": col_info.get("expanded_name", ""),
                        "description": col_info.get("description", ""),
                        "data_format": col_info.get("data_format", ""),
                        "value_description": col_info.get("value_description", ""),
                        "value_examples": col_info.get("value_examples", [])
                    }
            table["columns_info"] = columns_info
        
        return linked_schema
    
    def enhance_schema_only_with_keys(self, linked_schema: Dict, database_schema: Dict) -> Dict:
        """
        Enhance the schema only with primary keys and foreign keys, without additional information and sample values
        
        :param linked_schema: The result of Schema Linking
        :param database_schema: The original database schema
            
        :return: Dict: The enhanced schema
        """
        enhanced_schema = {"tables": []}
        
        # Get the primary key and foreign key information of the tables in the database
        table_info = {}
        for table in database_schema["tables"]:
            table_info[table["table"]] = {
                "primary_keys": table.get("primary_keys", []),
                "foreign_keys": table.get("foreign_keys", [])
            }
        
        # Add primary key and foreign key information to each linked table
        for table in linked_schema.get("tables", []):
            table_name = table["table"]
            columns = set(table["columns"])  # Use set for efficient lookup
            
            if table_name in table_info:
                # Add primary key columns
                for pk in table_info[table_name]["primary_keys"]:
                    columns.add(pk)
                
                # Add foreign key columns
                for fk in table_info[table_name]["foreign_keys"]:
                    columns.add(fk["column"])
            
            # Create the enhanced table object
            enhanced_table = {
                "table": table_name,
                "columns": list(columns)  # Convert to list
            }
            
            # Add primary key and foreign key information (if exists)
            if table_name in table_info:
                if table_info[table_name]["primary_keys"]:
                    enhanced_table["primary_keys"] = table_info[table_name]["primary_keys"]
                
                # Add foreign key information
                foreign_keys = []
                for fk in table_info[table_name]["foreign_keys"]:
                    if fk["column"] in columns:
                        foreign_keys.append(fk)
                if foreign_keys:
                    enhanced_table["foreign_keys"] = foreign_keys
            
            enhanced_schema["tables"].append(enhanced_table)
            
        return enhanced_schema
    
    async def link_schema(self, query: str, database_schema: Dict, query_id: str = None) -> str:
        """
        Execute schema linking
        
        :param query: The user's natural language query
        :param database_schema: The database schema information
        :param query_id: The unique identifier for the query
            
        :return: str: The linked schema information
        """
        # Use the schema manager's formatting method
        schema_str = self.schema_manager.format_enriched_db_schema(database_schema)

        # Get evidence
        data_file = self.data_file
        dataset_examples = load_json(data_file)
        curr_evidence = ""
        for item in dataset_examples:
            if(item.get("question_id") == query_id):
                curr_evidence = item.get("evidence", "")
                break
        
        # Record the formatted schema for inspection
        self.logger.debug("Formatted Schema Information:")
        self.logger.debug("\n" + schema_str)
        
        messages = [
            {"role": "system", "content": ENHANCED_SCHEMA_SYSTEM},
            {"role": "user", "content": BASE_SCHEMA_USER.format(
                schema_str=schema_str,
                query=query,
                evidence=curr_evidence if curr_evidence else "None"
            )}
        ]
        # print('\n'+messages[1]['content']+'\n')
        
        result = await self.llm.call_llm(
            messages,
            self.model,
            temperature=self.temperature,
            max_tokens=self.max_tokens,
            module_name=self.name
        )
        
        raw_output = result["response"]
        extracted_linked_schema = self.extractor.extract_schema_json(raw_output)
        
        # Validate the extracted schema
        if not extracted_linked_schema or not self._validate_linked_schema(extracted_linked_schema, database_schema):
            raise ValueError("Schema linking result validation failed: Contains non-existent tables or columns")
        
        # print(raw_output)
        # print("****before enhance*****\n", extracted_linked_schema, "\n*********")
        
        # Enhance the schema information: Add necessary primary keys, foreign keys, and additional information
        enhanced_linked_schema = self._enhance_linked_schema(extracted_linked_schema, database_schema)
        # print("****after enhance*****\n", enhanced_linked_schema, "\n*********")

        # Enhance the schema information: Add necessary primary keys, foreign keys, and additional information
        enhanced_linked_schema_wo_info = self.enhance_schema_only_with_keys(extracted_linked_schema, database_schema)
        # print("****after enhance*****\n", enhanced_linked_schema_wo_info, "\n*********")
        
        # Format the linked schema
        formatted_linked_schema = self.schema_manager.format_linked_schema(enhanced_linked_schema)
        # print("****after format*****\n", formatted_linked_schema, "\n*********")

        # Save intermediate results
        self.save_intermediate(
            input_data={
                "query": query, 
                # "database_schema": database_schema,
                # "formatted_schema": schema_str,
                # "messages": messages
            },
            output_data={
                "raw_output": raw_output,
                "extracted_linked_schema": extracted_linked_schema,
                "enhanced_linked_schema": enhanced_linked_schema,  # Add the enhanced schema
                "enhanced_linked_schema_wo_info": enhanced_linked_schema_wo_info,
                "formatted_linked_schema": formatted_linked_schema
            },
            model_info={
                "model": self.model,
                "input_tokens": result["input_tokens"],
                "output_tokens": result["output_tokens"],
                "total_tokens": result["total_tokens"]
            },
            query_id=query_id
        )
        
        self.log_io(
            {
                "query": query, 
                "database_schema": database_schema, 
                "formatted_schema": schema_str,
                "messages": messages
            }, 
            raw_output
        )
        
        # Save the enhanced linked schema result (without extra info)
        # Get source from the database_schema or a default value
        source = database_schema.get("source", "unknown")
        self.save_linked_schema_result(
            query_id=query_id,
            source=source,
            linked_schema={
                "database": database_schema.get("database", ""),
                "tables": enhanced_linked_schema_wo_info.get("tables", [])
            }
        )
        
        return raw_output 

    # def save_linked_schema_result(self, query_id: str, source: str, linked_schema: Dict) -> None:
    #     """
    #     Save the linked schema result to a separate JSONL file.
        
    #     Args:
    #         query_id: Query ID
    #         source: Data source (e.g., 'bird_dev')
    #         linked_schema: The linked schema with primary/foreign keys
    #     """
    #     # Get the pipeline directory from the intermediate result handler
    #     pipeline_dir = self.intermediate.pipeline_dir
        
    #     # Define the output file path
    #     output_file = os.path.join(pipeline_dir, "linked_schema_results.jsonl")
        
    #     # Format the result in the specified structure
    #     result = {
    #         "query_id": query_id,
    #         "source": source,
    #         "database": linked_schema.get("database", ""),
    #         "tables": [
    #             {
    #                 "table": table["table"],
    #                 "columns": table["columns"]
    #             }
    #             for table in linked_schema.get("tables", [])
    #         ]
    #     }
        
    #     # Save to JSONL file
    #     with open(output_file, "a", encoding="utf-8") as f:
    #         f.write(json.dumps(result, ensure_ascii=False) + "\n")  